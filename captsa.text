<!-- HTML placeholders -->
<div id="captcha-question"></div>
<input type="text" id="captcha-answer" name="captcha_answer" required>

<script>
const pool = [
  {q: "Which is not an animal? 🐶 🐱 🍕", a: "🍕"},
  {q: "Type the word: bleep", a: "bleep"},
  {q: "What is 2 + 3?", a: "5"},
  {q: "Which one you can eat? Rock / Banana / Keyboard", a: "banana"}
];
// pick random
const choice = pool[Math.floor(Math.random()*pool.length)];
document.getElementById('captcha-question').textContent = choice.q;
// store expected answer in a hashed form (or better: store on server session)
sessionStorage.setItem('captchaAnswer', choice.a.toLowerCase());
</script>
Recommended anti-spam stack (minimum)

Honeypot field (hidden) — catches naive bots.

Time check — block submissions faster than human fill time (e.g., <3s).

Randomized human question (from pool) — simple, funny.

Server-side validation + rate limiting.

Optional: Email confirmation or CAPTCHA fallback for suspicious traffic.

Optional: third-party spam filters (Akismet, StopForumSpam).

Example implementations
1) Honeypot (HTML + server checks)

Add hidden field (CSS hides it; real users don’t fill it; bots often do).

<!-- HTML -->
<form id="contact" method="POST" action="/submit">
  <input type="text" name="name" required>
  <input type="email" name="email" required>
  <!-- Honeypot field (hide via CSS) -->
  <div style="display:none">
    <label>Leave this empty</label>
    <input type="text" name="hp_phone" autocomplete="off">
  </div>
  <button type="submit">Send</button>
</form>


Server-side: reject if hp_phone is non-empty.

2) Time-based check (JS + server)

Record when form was shown and when submitted.

<input type="hidden" id="form_timestamp" name="form_timestamp" value="">
<script>
  document.getElementById('form_timestamp').value = Date.now();
  // On submit, send timestamp — server rejects if (now - timestamp) < 2500 ms
</script>


Server: if submission time minus form_timestamp < 2500 ms, treat as bot.

3) Randomized short human question (JS + server)

Pool of funny/short questions. Validate server-side.

<!-- HTML placeholders -->
<div id="captcha-question"></div>
<input type="text" id="captcha-answer" name="captcha_answer" required>

<script>
const pool = [
  {q: "Which is not an animal? 🐶 🐱 🍕", a: "🍕"},
  {q: "Type the word: bleep", a: "bleep"},
  {q: "What is 2 + 3?", a: "5"},
  {q: "Which one you can eat? Rock / Banana / Keyboard", a: "banana"}
];
// pick random
const choice = pool[Math.floor(Math.random()*pool.length)];
document.getElementById('captcha-question').textContent = choice.q;
// store expected answer in a hashed form (or better: store on server session)
sessionStorage.setItem('captchaAnswer', choice.a.toLowerCase());
</script>


On submit, compare server-side to the chosen answer (don’t trust client).

4) Simple drag-and-drop puzzle (client + server fallback)

Short description: show an image with a gap and a piece to drag. Validate position on submit. For accessibility, include an alternative text question or a keyboard version (e.g., choose from list).

(Implementing the full drag code is longer — I can provide it if you want.)

Sample pool of fun captcha questions (editable)

“Which of these is not a fruit? 🍎 🍌 🪨” → 🪨

“Type the third word of this sentence: ‘Sunny cats jump’” → jump

“Robots say ‘beep’. Type what they say: beep”

“How many wheels on a bicycle?” → 2

“Choose the object you can eat: Chair / Apple / Lamp” → Apple

“What color is the sky on a clear day?” → blue

Security caveats

Advanced bots can parse simple Q&A if static — always randomize and validate server-side.

Machine-learning bots might handle images and emojis; mixing text and contextual questions helps.

Don’t disclose correct answers client-side in plain text. Use server session or hashed tokens.

Quick recommended setup (easy + effective)

Honeypot field.

Time check (e.g., min 2.5s).

Randomized short question from a pool (server-validated).

Rate limiting by IP + optional email verification for suspicious submissions.

Optional: human review queue if flagged.

This combo is low friction, accessible, amusing for users, and significantly raises the bar for spammers.

Want me to:

generate a ready-to-drop JS + Node/Python server example that implements honeypot + time + randomized question with server validation?

or write a drag-and-drop puzzle implementation (with keyboard support and fallback)?

Tell me which and I’ll produce the code.

Principles to follow

Combine layers — don’t rely on one CAPTCHA alone. Use e.g. honeypot + time check + friendly human question.

Randomize content/questions so bots can’t be hard-coded.

Keep it accessible — provide text alternatives and avoid only visual puzzles.

Make it short & funny — reduces friction and improves conversions.

Server-side validation — always validate on server, never trust client JS alone.

Charming / funny human-check ideas

(Use a randomized pool so bots can’t memorize answers.)

“Pick the odd one out (emoji)”
“Which emoji doesn’t belong? 🐶 🐱 🐰 🍕” → answer: 🍕.
Friendly and fast.

Silly Q&A
“If a robot says ‘bleep-bloop’, type what it said (bleep-bloop).”
Simple but human-readable and you can randomize phrases.

Contextual question about the page
“What color is the big button on this page?” (Works if UI is consistent.)

Drag the missing puzzle piece
Small image with one piece missing; user drags the piece into place.

Simple logic with a twist
“I have 2 red socks and 3 blue socks. How many socks in total?” — easy for humans; variable wording prevents scraping.

Short phrase transcription
Show a short sentence image (or audio) and ask to type it. Use many variants.

Tiny interactive mini-game
E.g., click moving target once. (Careful with accessibility.)

“Human Sense” question
“Which of these is safe to eat? (Rock / Banana / Keyboard)” → Banana.

Accessibility notes

Offer text alternatives and audio for any visual puzzle.

Provide keyboard interaction for drag/drop.

Keep questions short, clear, and localized for your audience.

Recommended anti-spam stack (minimum)

Honeypot field (hidden) — catches naive bots.

Time check — block submissions faster than human fill time (e.g., <3s).

Randomized human question (from pool) — simple, funny.

Server-side validation + rate limiting.

Optional: Email confirmation or CAPTCHA fallback for suspicious traffic.

Optional: third-party spam filters (Akismet, StopForumSpam).